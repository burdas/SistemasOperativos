#ifndef _FRAGMENTA_#define _FRAGMENTA_#include <stdlib.h>#include <string.h>char** fragmenta (char* const cadena) {	// Se necesita recorrer la cadena de entrada dos veces	// - Primer recorrido sirve para contar el número de tokens que la componen	// - Segundo recorrido sirve para cargar el array de tokens  // Se consideran tokens separados por espacios en blanco o tabuladores  char* const delimitadores = " \t";	//	// Primer recorrido	//	// Se hace una copia de la cadena de entrada ya que la funcion strtok()	// modifica la cadena sobre la que opera incluyendo caracteres '\0'.	// Esa modificación causaría que el segundo recorrido operará sobre una	// cadena distinta a la original.  char* const copia = (char*) malloc(sizeof(char) * (strlen(cadena) + 1));  strcpy(copia, cadena);  	// Se cuenta el número de tokens separados por delimitadores	// que hay en la cadena de entrada.	int n = 0;  for (char* token = strtok(copia, delimitadores); token != NULL; token = strtok(NULL, delimitadores)) {    if (strlen(token) > 0)			++n;  }	// Se libera la memoria ocupada por la copia	free(copia);	//	// Segundo recorrido	//	// Se pide memoria para un array de (n + 1) tokens (punteros a argumentos)	// La posicion final se marcará con un token vacio.  char** const tokens = (char**) malloc (sizeof(char*) * (n + 1));	// Se carga el array de tokems	char* token = strtok(cadena, delimitadores);	for (int j = 0; j < n; ++j) {		// Se copia cada token no vacio    if (strlen(token) > 0) {			tokens[j] = (char*) malloc(sizeof(char) * (strlen(token) + 1));	// Una posición más para marca \0			strcpy(tokens[j], token);		}		//Se pasa al siguiente token    token = strtok(NULL, delimitadores);  }  // Se marca el array de tokens con un token vacio en su última posicion  tokens[n] = NULL;	// Se devuelve el puntero al array de tokens  return tokens;}void borrarg (char* tokens[]) {	// Se devuelve memoria ocupada por cada token	int j;  for (j = 0; tokens[j] != NULL; ++j)    free(tokens[j]);	// Se elimina token nulo final	free(tokens[j]);	// Se devuelve memoria ocupada por el array de tokens  free(tokens);}#endif // _FRAGMENTA_